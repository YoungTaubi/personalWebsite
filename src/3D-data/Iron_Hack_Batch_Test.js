/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import { MeshNormalMaterial } from 'three';
import { useFrame } from '@react-three/fiber';

export default function Model({ workExperienceYPos }) {

  const [executed, setExecuted] = useState(false)
  const [direction, setDiection] = useState('backward')
  const [speed, setSpeed] = useState(0)
  const group = useRef()
  const batchRef = useRef()
  const { nodes, materials } = useGLTF('/Iron-Hack-Batch-Compressed.glb')
  // console.log(materials);
  const normalMaterial = new MeshNormalMaterial()

  // console.log(batchRef);

  let velocity = 0
  let accelleration = 0.1
  // let speed = 0;
  let travel = 0

  // function move() {
  //   const id = setInterval(frame, 5);
  //   function frame() {
  //     velocity += accelleration
  //     speed += velocity;
  //     travel += speed
  //     if (travel > workExperienceYPos / 5) {

  //       velocity += accelleration
  //       speed -= velocity;
  //       if (speed < 0) {
  //         speed = 0
  //         velocity = 0
  //         travel = 0
  //         clearInterval(id)
  //       }
  //     }
  //   }
  // }

  const move = (direction, maxSpeed) => {
    const interval = setInterval(accellerate(direction), 1000);
    function accellerate(direction) {
      if (direction === 'forward') {
        if (speed > -maxSpeed) {
          velocity += accelleration
          setSpeed(prevSpeed => prevSpeed - velocity)
        } else {
          setSpeed(-maxSpeed)
        }
      }
      if (direction === 'backward') {
        if (speed < maxSpeed) {
          velocity += accelleration
          setSpeed(prevSpeed => prevSpeed + velocity)
        } else {
          setSpeed(maxSpeed)
        }
      }
      if (direction === 'brake') {
        if (speed > 0) {
          console.log('test1')
          velocity += accelleration
          setSpeed(prevSpeed => prevSpeed - velocity)
          if (speed < 0) {
            console.log('test2');
            clearInterval(interval)
            velocity = 0
            setSpeed(0)
          }
        }
        if (speed <= 0) {
          console.log('test0')
          velocity += accelleration
          setSpeed(prevSpeed => prevSpeed + velocity)
          // if (speed === 0) {
          //   console.log('test schluss +++++++++++++++');
          //   velocity = 0
          //   setSpeed(0)
          //   console.log('test schluss +++++++++++++++');
          //   clearInterval(interval)
          //   return
          // }
        }
      }

    }
  }


  // const accellerate = () => {
  //   const accellerationInterval = setInterval(accellerate, 5);
  //   function accellerate() {
  //     velocity += accelleration
  //     speed += velocity;
  //     travel += speed
  //   }
  // }





  useFrame(() => {
    const test = direction
    move(test, 3)
    if (batchRef.current.position.x < -10) {
      setDiection('brake')
      // setDiection('backward')
    }
    if (batchRef.current.position.x > 20) {
      setDiection('forward')
    }
    console.log(batchRef.current.position.x.toFixed(1), speed.toFixed(1), direction);
    // if (batchRef.current.position.x > -100) {
    //   console.log('forward');
    //   move(direction, 3)
    // }
    // if (batchRef.current.position.x > 0) {
    //   console.log('backward');
    //   move('backward', 3)
    // }


    // if (!executed) {
    //   move('forward', 3)
    //   setTimeout(() => { setExecuted(true) }, 1000)
    // }
    // console.log(window.scrollY);
    batchRef.current.position.x += speed

  })

  const flyAnimation = () => {

  }

  return (

    <group ref={group} dispose={null} scale={0.05} rotation={[-0.5, -0.5, -0.2]} position={[-10, 0, 0]}>
      {/* <mesh geometry={nodes.Cube.geometry} material={materials.Material} /> */}
      <mesh geometry={nodes['20220428_Iron_Crypto_Logo'].geometry} material={normalMaterial} rotation={[Math.PI / 2, 0, 0]} ref={batchRef} />
    </group>


  )
}

useGLTF.preload('/Iron-Hack-Batch-Compressed.glb')
