/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState, useCallback, useEffect } from 'react'
import { useGLTF } from '@react-three/drei'
import { MeshNormalMaterial } from 'three';
import { useFrame } from '@react-three/fiber';
import { RGBA_ASTC_5x4_Format } from 'three';

export default function Model({ workExperienceYPos }) {

  const [executed, setExecuted] = useState(false)
  const [direction, setDirection] = useState('forward')
  const [speed, setSpeed] = useState(0)
  const [velocity, setVelocity] = useState(0)
  const [distance, setDistance] = useState(0)
  const [brake, setBrake] = useState(false)
  const [initialCall, setInitialCall] = useState(true)
  const [initialCall2, setInitialCall2] = useState(true)
  const group = useRef()
  const batchRef = useRef()
  const { nodes, materials } = useGLTF('/Iron-Hack-Batch-Compressed.glb')
  // console.log(materials);
  const normalMaterial = new MeshNormalMaterial()

  // console.log(batchRef);

  // let velocity = 0
  // let accelleration = 0.01
  // let speed = 0;
  // let distance = 0

  // function move() {
  //   const id = setInterval(frame, 5);
  //   function frame() {
  //     velocity += accelleration
  //     speed += velocity;
  //     travel += speed
  //     if (travel > workExperienceYPos / 5) {

  //       velocity += accelleration
  //       speed -= velocity;
  //       if (speed < 0) {
  //         speed = 0
  //         velocity = 0
  //         travel = 0
  //         clearInterval(id)
  //       }
  //     }
  //   }
  // }

  // let brake = false 

  const move = (element, direction, maxSpeed, maxDist, axis, accelleration) => {
    if (direction === 'forward') {
      if (distance > maxDist) {
        setDirection('brake')
      }
      if (speed > -maxSpeed) {
        setVelocity(prevVelo => prevVelo + accelleration)
        setDistance(prevDist => prevDist + velocity)
        setSpeed(prevSpeed => prevSpeed - velocity)
      } else {
        setSpeed(-maxSpeed)
        setDistance(prevDist => prevDist + velocity)
      }
    }
    if (direction === 'backward') {
      if (distance > maxDist) {
        setDirection('brake')
      }
      if (speed < maxSpeed) {
        setVelocity(prevVelo => prevVelo + accelleration)
        setDistance(prevDist => prevDist + velocity)
        setSpeed(prevSpeed => prevSpeed + velocity)
      } else {
        setSpeed(maxSpeed)
        setDistance(prevDist => prevDist + velocity)
      }
    }

    // if (direction === 'brake') {
    //   // if (brake) {
    //   //   setSpeed(0)
    //   // }
    //   if (speed > 0 && !brake) {
    //     setVelocity(prevVelo => prevVelo + accelleration)
    //     setSpeed(prevSpeed => prevSpeed - velocity)
    //     if (Number(speed.toFixed(2)) === 0) {
    //       setBrake(true)
    //       setVelocity(0)
    //       setDistance(0)
    //       setSpeed(0)
    //     }
    //   }
    //   if (speed < 0 && !brake) {
    //     setVelocity(prevVelo => prevVelo + accelleration)
    //     setSpeed(prevSpeed => prevSpeed + velocity)
    //     if (Number(speed.toFixed(2)) === 0) {
    //       setBrake(true)
    //       setVelocity(0)
    //       setDistance(0)
    //       setSpeed(0)
    //     }
    //   }
    // }

    if (direction === 'brake' && speed > 0 && !brake) {
      // console.log('brems1');
      setVelocity(prevVelo => prevVelo + accelleration)
      setSpeed(prevSpeed => prevSpeed - velocity)
      if (speed < 0) {
        setBrake(true)
        setVelocity(0)
        setDistance(0)
        setSpeed(0)
      }

    }
    if (direction === 'brake' && speed < 0 && !brake) {
      // console.log('brems2');
      setVelocity(prevVelo => prevVelo + accelleration)
      setSpeed(prevSpeed => prevSpeed + velocity)
      if (speed > -0.5) {
        // console.log('brems2.2');
        setBrake(true)
        setVelocity(0)
        setDistance(0)
        setSpeed(0)
      }
    }
    element.current.position[axis] += speed
  }


  // const accellerate = () => {
  //   const accellerationInterval = setInterval(accellerate, 5);
  //   function accellerate() {
  //     velocity += accelleration
  //     speed += velocity;
  //     travel += speed
  //   }
  // }

  /////////////////////////////////////////////////////////

  const [y, setY] = useState(window.scrollY);

const handleNavigation = useCallback(
  e => {
    const window = e.currentTarget;
    if (y > window.scrollY) {
      console.log("scrolling up");
    } else if (y < window.scrollY) {
      console.log("scrolling down");
    }
    setY(window.scrollY);
  }, [y]
);

useEffect(() => {
  setY(window.scrollY);
  window.addEventListener("scroll", handleNavigation);

  return () => {
    window.removeEventListener("scroll", handleNavigation);
  };
}, [handleNavigation]);


/////////////////////////////////////////////////////////////




  useFrame(() => {
    // console.log('distance', distance, 'velocity', velocity, 'speed', speed, 'direction', direction, brake);
    console.log(initialCall, initialCall2);
    // move(batchRef, direction, 3, 20, 'x', 0.01)

    if (window.scrollY > workExperienceYPos - 300 && window.scrollY < workExperienceYPos - 100) {
      if (initialCall2) {
        setInitialCall(true)
        setDirection('forward')
        setBrake(false)
        setInitialCall2(false)
      }

      move(batchRef, direction, 5, 7, 'x', 0.005)
    }
    if (window.scrollY > workExperienceYPos - 100) {

      if (initialCall) {
        setInitialCall2(true)
        setDirection('backward')
        setBrake(false)
        setInitialCall(false)
      }

      move(batchRef, direction, 5, 7, 'x', 0.005)
    }
    // if (window.scrollY > workExperienceYPos) {
    //   console.log('go', window.scrollY);
    //   setDirection('brake')
    // }
    // console.log(batchRef.current.position.x.toFixed(1), speed.toFixed(1), direction);
    // if (batchRef.current.position.x > -100) {
    //   console.log('forward');
    //   move(direction, 3)
    // }
    // if (batchRef.current.position.x > 0) {
    //   console.log('backward');
    //   move('backward', 3)
    // }


    // if (!executed) {
    //   move('forward', 3)
    //   setTimeout(() => { setExecuted(true) }, 1000)
    // }
    // console.log(window.scrollY);

  })

  return (

    <group ref={group} dispose={null} scale={0.05} rotation={[-0.5, -0.5, -0.2]} position={[-1, -workExperienceYPos / 50 + 5, 5]}>
      {/* <mesh geometry={nodes.Cube.geometry} material={materials.Material} /> */}
      <mesh geometry={nodes['20220428_Iron_Crypto_Logo'].geometry} material={normalMaterial} rotation={[Math.PI / 2, 0, 0]} ref={batchRef} position={[150, 0, 0]} />
    </group>


  )
}

useGLTF.preload('/Iron-Hack-Batch-Compressed.glb')
