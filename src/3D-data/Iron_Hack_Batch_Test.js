/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState } from 'react'
import { useGLTF } from '@react-three/drei'
import { MeshNormalMaterial } from 'three';
import { useFrame } from '@react-three/fiber';

export default function Model({ workExperienceYPos }) {

  const [executed, setExecuted] = useState(false)
  const [direction, setDiection] = useState('backward')
  const [speed, setSpeed] = useState(0)
  const group = useRef()
  const batchRef = useRef()
  const { nodes, materials } = useGLTF('/Iron-Hack-Batch-Compressed.glb')
  // console.log(materials);
  const normalMaterial = new MeshNormalMaterial()

  // console.log(batchRef);

  let velocity = 0
  let accelleration = 0.01
  // let speed = 0;
  let travel = 0

  // function move() {
  //   const id = setInterval(frame, 5);
  //   function frame() {
  //     velocity += accelleration
  //     speed += velocity;
  //     travel += speed
  //     if (travel > workExperienceYPos / 5) {

  //       velocity += accelleration
  //       speed -= velocity;
  //       if (speed < 0) {
  //         speed = 0
  //         velocity = 0
  //         travel = 0
  //         clearInterval(id)
  //       }
  //     }
  //   }
  // }

  const move = (direction2, maxSpeed) => {
    const interval = setInterval(accellerate(direction2), 1000);
    console.log('01', direction2);
    function accellerate(direction2) {
      if (direction2 === 'forward') {
        console.log('forward');
        // setSpeed(prevSpeed => prevSpeed + accelleration)
        // if (speed < maxSpeed) {
        velocity += accelleration
        setSpeed(prevSpeed => prevSpeed + velocity)
        // }
        // speed += velocity;
        // else {
        //   setSpeed(maxSpeed)
        //   //  speed = maxSpeed
        // }
      }
      if (direction2 === 'backward') {
        console.log('internal', direction2);
        // if (speed > -maxSpeed) {
        velocity += accelleration
        setSpeed(prevSpeed => prevSpeed - velocity)
        // }
        // speed += velocity;
        // else {
        //   setSpeed(-maxSpeed)
        //  speed = maxSpeed
        // }
        // setSpeed(prevSpeed => prevSpeed - accelleration)
        // velocity += accelleration
        // speed -= velocity;
        // if (speed < -maxSpeed) {
        //   speed = -maxSpeed
        // }
        // travel += speed
      } else if (direction === 'brake') {
        velocity += accelleration
        speed -= velocity;
        if (speed < 0) {
          // speed = 0
          velocity = 0
          travel = 0
          clearInterval(interval)
        }
      }
    }
  }

  // const accellerate = () => {
  //   const accellerationInterval = setInterval(accellerate, 5);
  //   function accellerate() {
  //     velocity += accelleration
  //     speed += velocity;
  //     travel += speed
  //   }
  // }





  useFrame(() => {
    const test = direction
    move(test, 3)
    if (batchRef.current.position.x < -10) {
      setDiection('backward')
      // setDiection('backward')
    }
    if (batchRef.current.position.x > 10) {
      setDiection('forward')
    }
    console.log(batchRef.current.position.x.toFixed(1), speed.toFixed(1), direction);
    // if (batchRef.current.position.x > -100) {
    //   console.log('forward');
    //   move(direction, 3)
    // }
    // if (batchRef.current.position.x > 0) {
    //   console.log('backward');
    //   move('backward', 3)
    // }


    // if (!executed) {
    //   move('forward', 3)
    //   setTimeout(() => { setExecuted(true) }, 1000)
    // }
    // console.log(window.scrollY);
    batchRef.current.position.x += speed

  })

  const flyAnimation = () => {

  }

  return (

    <group ref={group} dispose={null} scale={0.05} rotation={[-0.5, -0.5, -0.2]} position={[0, 0, 0]}>
      {/* <mesh geometry={nodes.Cube.geometry} material={materials.Material} /> */}
      <mesh geometry={nodes['20220428_Iron_Crypto_Logo'].geometry} material={normalMaterial} rotation={[Math.PI / 2, 0, 0]} ref={batchRef} />
    </group>


  )
}

useGLTF.preload('/Iron-Hack-Batch-Compressed.glb')
